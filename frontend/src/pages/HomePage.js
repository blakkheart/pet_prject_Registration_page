import React, { useState, useEffect, useContext } from 'react';
import AuthContext from '../context/AuthContext';


// главная страница
const HomePage = () => {

    // задаем переменную {note} и функцию {setNote}, через которую будем заносить данныве в {note}
    let [note, setNote] = useState([])
    // забираем из контекста перменную, отвечающую за токен пользователя, и функцию логаута пользователя
    let { authToken, logoutUser } = useContext(AuthContext)

    // при монтировании компонента используется {useEffect}
    // и задаются записки через функцию {getNotes}
    // ?? - мое понимание
    // если нет зависимостей - {useEffect} будет использован как при маунте, так и при апдейте
    // если пустые зависимости [] - это значит что используем данные, которые не в потоке реакта, "сторонние"
    // в ином случае внутри [] указываются перменные, что используются внутри функции внутри {useEffect}
    // в случае указания пустых зависимостей, {useEffect} вызывается лишь единожды - при маунте
    // в случае указания зависимостей, {useEffect} вызывается при маунте, а так же каждый раз при изменении любой переменной из зависимостей
    //
    // т.к. в данном случае в {getNotes} нет ничего, кроме данных, зафетченных из апи, 
    // и нам нет необходимости при каждом апдейте обновлять записки, т.к. мы можем загрузить их один раз во время маунта
    // добавляем пустые зависимости
    useEffect(() => {
        getNotes()
    }, [])

    // функция получения записок пользователя
    // используем асинхронную функцию {async}
    let getNotes = async () => {
        // фетчим наш апи с указанием в header ключа авторизации jwt
        // используем {await}, дабы дождаться записи данных в переменную
        let response = await fetch('http://127.0.0.1:8000/api/notes/', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + String(authToken.access)
            }
        })
        // преобразовывает JSON формат в JavaScript object
        // используем await, дабы дождаться записи данных в переменную
        // т.к. функция {.json()} возвращает Promise
        let data = await response.json()

        // проверяем респонс от сервера, чтобы не словить ошибки
        // если респонс окей {status == 200}, то записываем данные, полученные 
        // из апи, в перменную {note} с помощью функции {setNote}
        // иначе проверяем, если ошибка в авторизации (джанго хранит это в поле {statusTextd} внутри респонс)
        // (например, когда токен истек, "сломался", etc), то с помощию функции {logoutUser} разлогиниваем пользователя
        if (response.status === 200) {
            setNote(data)
        } else if (response.statusText === 'Unauthorized') {
            logoutUser()
        }

    }

    // с помощью функции map проходимся по массиву {note}, куда мы записали ответ от апи со всеми записками
    // ?? если пусто в {note}, то может быть ошибка, надо проверить
    // для каждой {note} будем задавать ключ по айди записки (чтобы сделать их уникальными)
    // и выводить в списке <li>
    return (
        <div>
            <p>You are logged in, here is your notes:</p>
            <ul>
                {note.map(note => (
                    <li key={note.id}>
                        {note.body}
                    </li>
                ))}
            </ul>
        </div>
    )
}

export default HomePage